name: Update ACCESS-MOPPeR on Analysis3 Conda Environment
# This workflow updates the `access-mopper` package version in the Analysis3 conda environment
# whenever a new release of `access-mopper` is published.

on:
  release:
    types: ['released', 'prereleased']
  workflow_dispatch:

jobs:
  bump-env-in-repo-b:
    runs-on: ubuntu-latest
    permissions:
      contents: read
    env:
      ORG: ACCESS-NRI
      TARGET_REPO: ACCESS-Analysis-Conda
      TARGET_BRANCH: main
      FILE_PATH: environments/analysis3/environment.yml
      PACKAGE: access-mopper
      CHANNEL: accessnri
      # Derive version from the release tag (e.g. v2.3.0a4 -> 2.3.0a4).
      RELEASE_TAG: ${{ github.event.release.tag_name }}
      GH_TOKEN: ${{ secrets.GH_ANALYSIS3_DEPLOY }}

    steps:
      - name: Derive version string
        id: ver
        run: |
          tag="${RELEASE_TAG}"
          ver="${tag#v}"
          echo "version=$ver" >> $GITHUB_OUTPUT

      - name: Install tooling (jq, gh, Python deps)
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq python3-pip
          # gh CLI
          if ! command -v gh >/dev/null; then
            curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg \
              | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
            sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg
            echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" \
              | sudo tee /etc/apt/sources.list.d/github-cli.list >/dev/null
            sudo apt-get update -y && sudo apt-get install -y gh
          fi
          python3 -m pip install --upgrade pip
          python3 -m pip install ruamel.yaml

      - name: Wait for conda package to appear in channel
        env:
          VERSION: ${{ steps.ver.outputs.version }}
        run: |
          echo "Waiting for ${CHANNEL}::${PACKAGE}==${VERSION} to appear…"
          # Up to 30 minutes, check every 60s. Adjust if your CD pipeline needs longer.
          for i in $(seq 1 30); do
            # Query Anaconda API for package files in the channel
            if curl -fsSL "https://api.anaconda.org/package/${CHANNEL}/${PACKAGE}" | \
               jq -e --arg v "$VERSION" '.files[] | select(.version == $v) | .version' >/dev/null; then
              echo "Found ${PACKAGE} ${VERSION} in channel ${CHANNEL}."
              exit 0
            fi
            echo "Not yet available. Retry $i/30…"
            sleep 60
          done
          echo "Timed out waiting for ${CHANNEL}::${PACKAGE}==${VERSION}."
          exit 1

      - name: Clone Repo B
        run: |
          git clone "https://x-access-token:${GH_TOKEN}@github.com/${ORG}/${TARGET_REPO}.git"
          cd "${TARGET_REPO}"
          git config user.name "access-bot"
          git config user.email "access-bot@users.noreply.github.com"

      - name: Create branch and update environment.yml
        id: edit
        working-directory: ${{ env.TARGET_REPO }}
        env:
          VERSION: ${{ steps.ver.outputs.version }}
        run: |
          BRANCH="bump-${{ env.PACKAGE }}-${VERSION}"
          git fetch origin "${TARGET_BRANCH}"
          git checkout -b "$BRANCH" "origin/${TARGET_BRANCH}"

          python3 - <<'PY'
          from ruamel.yaml import YAML
          from ruamel.yaml.comments import CommentedSeq
          from pathlib import Path
          import os, sys

          path = Path("${{ env.FILE_PATH }}")
          version = os.environ["VERSION"]
          target = f"accessnri::access-mopper=={version}"

          yaml = YAML()
          yaml.preserve_quotes = True
          yaml.width = 4096
          yaml.indent(mapping=2, sequence=2, offset=2)

          text = path.read_text(encoding="utf-8")
          data = yaml.load(text)

          deps = data.get("dependencies", CommentedSeq())
          if not isinstance(deps, list):
            print("ERROR: dependencies is not a list", file=sys.stderr)
            sys.exit(1)

          replaced = False
          for i, d in enumerate(deps):
            if isinstance(d, str) and d.startswith("accessnri::access-mopper=="):
              if d != target:
                deps[i] = target
              replaced = True
              break

          if not replaced:
            deps.append(target)

          data["dependencies"] = deps
          with open(path, "w", encoding="utf-8") as f:
            yaml.dump(data, f)
          PY

          git add "${FILE_PATH}"
          if git diff --cached --quiet; then
            echo "changed=false" >> $GITHUB_OUTPUT
            echo "No changes to commit."
          else
            git commit -m "analysis3: bump access-mopper to ${VERSION}"
            git push -u origin "$BRANCH"
            echo "changed=true" >> $GITHUB_OUTPUT
            echo "$BRANCH" > ../branch.txt
          fi

      - name: Create PR (idempotent)
        if: steps.edit.outputs.changed == 'true'
        working-directory: ${{ env.TARGET_REPO }}
        env:
          VERSION: ${{ steps.ver.outputs.version }}
        run: |
          BRANCH="$(cat ../branch.txt)"
          # Create PR; if it already exists, ignore failure
          gh pr create \
            --base "${TARGET_BRANCH}" \
            --head "${BRANCH}" \
            --title "Bump access-mopper to ${VERSION} in analysis3 env" \
            --body "Updates \`${FILE_PATH}\` to \`accessnri::access-mopper==${VERSION}\`."
          # Capture PR number (works whether newly created or pre-existing)
          gh pr view "${BRANCH}" --json number -q .number > ../pr_number.txt

      - name: Enable auto-merge
        if: steps.edit.outputs.changed == 'true'
        working-directory: ${{ env.TARGET_REPO }}
        run: |
          PR=$(cat ../pr_number.txt)
          # Requires Repo B setting: Settings → General → Allow auto-merge
          # Merge method must be allowed in repo settings
          gh pr merge "$PR" --auto --merge
          echo "Auto-merge enabled on PR #$PR."
